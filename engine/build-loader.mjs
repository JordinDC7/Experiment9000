/**
 * BUILD LOADER
 *
 * Reads League-importable ItemSets.json (generated by our optimizer)
 * and returns a stable "core build order" for a champion + role.
 *
 * Notes:
 * - ItemSets can include non-Summoner's Rift variants (e.g. 223006). We normalize to SR ids.
 * - Role selection order:
 *    1) explicit roleHint (if available)
 *    2) infer from champion tags
 *    3) sensible fallback order: ADC → MID → TOP → JUNGLE → SUPPORT
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT = path.resolve(__dirname, "..");

const ITEMS_PATH = path.join(ROOT, "data", "items.json");
const ITEMSETS_PATH = path.join(ROOT, "league", "ItemSets.json");

let _items = null;
let _itemSets = null;

function loadItems() {
  if (_items) return _items;
  const raw = JSON.parse(fs.readFileSync(ITEMS_PATH, "utf8"));
  _items = raw.items || raw;
  return _items;
}

function loadItemSets() {
  if (_itemSets) return _itemSets;
  const raw = JSON.parse(fs.readFileSync(ITEMSETS_PATH, "utf8"));
  _itemSets = raw.itemSets || [];
  return _itemSets;
}

function isSRBuyable(item) {
  if (!item) return false;
  if (item.gold?.purchasable === false) return false;
  // SR map id is 11; some datasets use string keys
  const maps = item.maps || {};
  if (maps["11"] === false) return false;
  // If map info missing, assume buyable (better than blank output)
  return true;
}

export function normalizeItemIdForSR(itemId) {
  const items = loadItems();
  const raw = String(itemId || "");
  if (!raw) return raw;

  // Already SR-buyable
  const direct = items[raw];
  if (direct && isSRBuyable(direct)) return raw;

  // Common Arena/alt prefix: 22xxxx -> xxxx
  if (raw.startsWith("22") && raw.length === 6) {
    const stripped = raw.slice(2);
    const it = items[stripped];
    if (it && isSRBuyable(it)) return stripped;
  }

  // Some weird ids are 6-digit where first 4 are the canonical item id (e.g. 667109 -> 6671)
  if (raw.length === 6) {
    const first4 = raw.slice(0, 4);
    const it = items[first4];
    if (it && isSRBuyable(it)) return first4;
  }

  // Fallback: use raw if present
  if (direct) return raw;
  return raw;
}

export function getItemName(itemId) {
  const items = loadItems();
  const norm = normalizeItemIdForSR(itemId);
  const it = items[String(norm)];
  return it?.name || `#${norm}`;
}

export function inferRoleFromTags(tags) {
  const t = (tags || []).map((x) => String(x).toLowerCase());
  if (t.includes("marksman")) return "ADC";
  if (t.includes("support")) return "SUPPORT";
  if (t.includes("mage")) return "MID";
  if (t.includes("assassin")) return "MID";
  if (t.includes("tank") || t.includes("fighter")) return "TOP";
  return null;
}

function normalizeRoleHint(roleHint) {
  const r = String(roleHint || "").toUpperCase();
  if (!r) return null;
  if (r === "BOTTOM") return "ADC";
  if (r === "UTILITY") return "SUPPORT";
  if (r === "MIDDLE") return "MID";
  if (["TOP", "JUNGLE", "MID", "ADC", "SUPPORT"].includes(r)) return r;
  return null;
}

function parseRoleFromTitle(title) {
  const up = String(title || "").toUpperCase();
  const roles = ["TOP", "JUNGLE", "MID", "ADC", "SUPPORT"];
  for (const r of roles) {
    if (up.includes(` ${r}`) || up.includes(`${r} `) || up.includes(r))
      return r;
  }
  return null;
}

function pickSetBlock(set) {
  const blocks = set?.blocks || [];
  if (!Array.isArray(blocks) || blocks.length === 0) return null;

  const core =
    blocks.find((b) =>
      String(b?.type || "")
        .toLowerCase()
        .includes("core")
    ) ||
    blocks.find((b) =>
      String(b?.type || "")
        .toLowerCase()
        .includes("start")
    ) ||
    blocks[0];

  return core || null;
}

function extractCoreOrderFromSet(set) {
  const block = pickSetBlock(set);
  const items = loadItems();
  if (!block) return [];

  const out = [];
  const list = Array.isArray(block.items) ? block.items : [];
  for (const it of list) {
    const rawId = String(it?.id || "");
    if (!rawId) continue;

    const norm = normalizeItemIdForSR(rawId);
    const meta = items[String(norm)];
    if (!meta) {
      out.push({ id: norm, name: `#${norm}` });
      continue;
    }

    // keep only SR-buyable items for the core order (prevents Arena-only ids)
    if (!isSRBuyable(meta)) continue;

    out.push({ id: String(norm), name: meta.name || `#${norm}` });
  }
  return out;
}

function chooseRole(rolesMap, roleHint, tags) {
  const hint = normalizeRoleHint(roleHint);
  if (hint && rolesMap[hint]) return hint;

  const inferred = inferRoleFromTags(tags);
  if (inferred && rolesMap[inferred]) return inferred;

  const fallback = ["ADC", "MID", "TOP", "JUNGLE", "SUPPORT"];
  for (const r of fallback) {
    if (rolesMap[r]) return r;
  }
  return Object.keys(rolesMap)[0] || null;
}

/**
 * Return { coreRole, coreOrder } or null
 */
export function getCoreBuild(championId, roleHint = null, champTags = []) {
  const sets = loadItemSets();
  const cid = Number(championId || 0);
  if (!cid) return null;

  const relevant = sets.filter((s) =>
    (s.associatedChampions || []).includes(cid)
  );
  if (!relevant.length) return null;

  // role -> best matching set
  const rolesMap = {};
  for (const s of relevant) {
    const role = parseRoleFromTitle(s.title) || "UNKNOWN";
    // first one wins unless we later want tie-breaking
    if (!rolesMap[role]) rolesMap[role] = s;
  }

  // If titles didn't encode roles, treat as single role
  if (rolesMap.UNKNOWN && Object.keys(rolesMap).length === 1) {
    const only = rolesMap.UNKNOWN;
    return {
      coreRole: "UNKNOWN",
      coreOrder: extractCoreOrderFromSet(only),
      title: only.title || "",
    };
  }

  const role = chooseRole(rolesMap, roleHint, champTags) || "UNKNOWN";
  const chosen = rolesMap[role] || rolesMap.UNKNOWN || relevant[0];

  return {
    coreRole: role,
    coreOrder: extractCoreOrderFromSet(chosen),
    title: chosen?.title || "",
  };
}

export { normalizeRoleHint };
